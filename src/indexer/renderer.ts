import type { TreeNode } from './types.js'

interface RenderOptions {
  siteName?: string
  siteDescription?: string
  fetchEndpoint?: string
  siteUrl?: string
}

/**
 * Render the tree to llmsmap.txt markdown format.
 */
export function renderIndex(root: TreeNode, options: RenderOptions = {}): string {
  const lines: string[] = []
  const title = options.siteName ?? root.title
  const siteUrl = options.siteUrl ?? ''
  const fetchEndpoint = options.fetchEndpoint ?? ''

  // === Header with credits ===
  lines.push(`# ${title}`)
  if (options.siteDescription ?? root.description) {
    lines.push(`> ${options.siteDescription ?? root.description}`)
  }
  lines.push('')
  lines.push(`> Generated by [llmsmap-txt](https://github.com/MichaelTheMay/llmsmap-txt) — by [Michael May](https://github.com/MichaelTheMay)`)
  lines.push('')
  lines.push('---')
  lines.push('')

  // === Query API instructions ===
  if (fetchEndpoint) {
    lines.push('## How to Use This Map')
    lines.push('')
    lines.push('This is a **composable content map**. Instead of downloading the entire site,')
    lines.push('select only the sections you need using the fetch endpoint below.')
    lines.push('')
    lines.push('### Fetch Endpoint')
    lines.push('')
    lines.push('```')
    lines.push(`GET ${fetchEndpoint}?sections=/path1,/path2&format=md`)
    lines.push('```')
    lines.push('')
    lines.push('### Parameters')
    lines.push('')
    lines.push('| Parameter | Type | Description |')
    lines.push('|-----------|------|-------------|')
    lines.push('| `sections` | comma-separated paths | Paths from the site map below. Supports wildcards: `/docs/*` |')
    lines.push('| `search` | keyword string | Search all page content for a keyword. Returns top matches. |')
    lines.push('| `format` | `md` \\| `txt` \\| `json` | Output format. Default: `md` |')
    lines.push('| `updated_after` | ISO date (`YYYY-MM-DD`) | Only return sections updated after this date. |')
    lines.push('| `limit` | number | Max results for search queries. Default: `10` |')
    lines.push('')
    lines.push('> **Note:** Provide either `sections` or `search`, not both.')
    lines.push('')
    lines.push('### Examples')
    lines.push('')
    // Pick up to 2 example paths from actual content
    const examplePaths = collectLeafPaths(root, 2)
    const exDir = examplePaths.length > 0 ? examplePaths[0].split('/').slice(0, 2).join('/') : '/docs'
    lines.push('Fetch specific sections:')
    lines.push('```')
    if (examplePaths.length >= 2) {
      lines.push(`GET ${fetchEndpoint}?sections=${examplePaths[0]},${examplePaths[1]}`)
    } else {
      lines.push(`GET ${fetchEndpoint}?sections=/about,/docs`)
    }
    lines.push('```')
    lines.push('')
    lines.push('Fetch all pages under a directory:')
    lines.push('```')
    lines.push(`GET ${fetchEndpoint}?sections=${exDir}/*`)
    lines.push('```')
    lines.push('')
    lines.push('Search for a topic:')
    lines.push('```')
    lines.push(`GET ${fetchEndpoint}?search=deployment&limit=5`)
    lines.push('```')
    lines.push('')
    lines.push('> **For LLMs:** Read the site map below, identify the sections relevant to the user\'s query,')
    lines.push('> then compose a single GET request with those paths as comma-separated `sections`.')
    lines.push('> Use wildcards (`/path/*`) to fetch entire directories. Use `search` when you need')
    lines.push('> to find content by keyword without knowing the exact path.')
    lines.push('> Two requests total: (1) this map, (2) the fetch call.')
    lines.push('')
    lines.push('---')
    lines.push('')
  }

  // === Site overview stats ===
  lines.push('## Site Map')
  lines.push('')
  lines.push(`> **${countLeaves(root)} pages** | **~${formatTokens(root.tokenCount)} tokens** total`)
  lines.push('')

  // === Hierarchical tree ===
  // Render root if it has content
  if (root.contentFile) {
    const ownTokens = root.tokenCount - childTokens(root)
    lines.push(`- **/** — ${root.title}  (~${formatTokens(ownTokens)} tokens, updated ${root.lastUpdated})`)
    if (root.description) {
      lines.push(`  > ${root.description}`)
    }
  }

  // Render all children as a clean tree
  for (const child of root.children) {
    renderNode(child, lines, 0)
  }

  lines.push('')
  return lines.join('\n')
}

function renderNode(node: TreeNode, lines: string[], indent: number): void {
  const pad = '  '.repeat(indent)
  const hasChildren = node.children.length > 0
  const isLeaf = !hasChildren && node.contentFile

  // Show token count: for directories show aggregate, for leaves show own
  const tokenStr = `~${formatTokens(node.tokenCount)} tokens`
  const bullet = hasChildren ? `${pad}- **${node.path}/**` : `${pad}- **${node.path}**`

  if (isLeaf) {
    lines.push(`${bullet} — ${node.title}  (${tokenStr}, updated ${node.lastUpdated})`)
  } else if (hasChildren) {
    lines.push(`${bullet} — ${node.title}  (${tokenStr} across ${countLeaves(node)} pages)`)
  } else {
    lines.push(`${bullet} — ${node.title}  (${tokenStr})`)
  }

  if (node.description) {
    lines.push(`${pad}  > ${node.description}`)
  }

  for (const child of node.children) {
    renderNode(child, lines, indent + 1)
  }
}

function formatTokens(count: number): string {
  if (count >= 1000) {
    return `${(count / 1000).toFixed(1)}k`.replace('.0k', 'k')
  }
  return count.toLocaleString()
}

function countLeaves(node: TreeNode): number {
  if (node.children.length === 0) return node.contentFile ? 1 : 0
  return node.children.reduce((sum, c) => sum + countLeaves(c), node.contentFile ? 1 : 0)
}

function childTokens(node: TreeNode): number {
  return node.children.reduce((sum, c) => sum + c.tokenCount, 0)
}

function collectLeafPaths(node: TreeNode, max: number, paths: string[] = []): string[] {
  if (paths.length >= max) return paths
  if (node.contentFile && node.path !== '/') {
    paths.push(node.path)
  }
  for (const child of node.children) {
    if (paths.length >= max) break
    collectLeafPaths(child, max, paths)
  }
  return paths
}
